{"content": "# Features\n\n\nPaella has some features that may make it desirable over other\nautomated installation options.\n\n## Self Hosting\n\nThe development environment, using [vagrant](https://vagrantup.com),\ncreates a [virtual box](http://virtualbox.org) server with two\ninterfaces that is ready to perform automated installs.  All that\nis needed is to clone the project from [github](https://github.com)\nand type `vagrant up` (and sadly,\nfollowed by one `vagrant provision`, due to a small bug in the ordering\nof states) and you are ready to start submitting machines and instaling.\n\nThe vagrant virtual machine can also install to bare metal if you bridge the\nsecondary network interface on the VM to a real network interace on the host.\n\n## Modern Design\n\nAfter spending the better part of thirteen years automatically installing and\nsemi-automatically maintaining configurations on quite a few debian systems,\nranging from servers to desktops and simple devices running debian, I have\nlearned plenty about installing debian systems, as well as a few others.\n\n### Debian Installer\n\nI have learned to make use of the debian installer to perform the initial\ninstall phase, rather than continue the tradition of debootstrapping from\na live system into a target directory on the system drive.  There are a\nsurprising about of small technical details that the debian installer handles,\nand these details happen to change from release to release in ways that\nforces more maintainence than is desired on the debootstrap install\nmethod.\n\nAt it's heart, if you pay close attention, the debian installer is an API for\ninstalling debian systems, controlled entirely by the preseed file and the\nkernel command line.  The debian developers provide all of the implementation\ndetails to install the system you declare in the preseed and command line.\nUsing the debian installer makes long term maintainence easier, at the\nexpense of having to keep track of the state of the machine when it\nreboots (thankfully, this is only once).  FIXME - there is another page\nthat gives details on how the install procedure operates.\n\n### Configuration Management\n\nConfiguration management extends beyond a preconfigured installation.  When\nthe desire to create an automated installer that created fully configured\nsystems originated, configuration management as it is seen today was\nnowhere nearly as mature.  There existed an assortment\nof less complete solutions to the serious problems that lack of good\nconfiguration managment eventually incurs.  Much of it required writing\nin perl, which I really don't like using.  I was forced, as many other\nadministrators at the time, to implement a hand-rolled solution, which,\nas expected, was less than completely satisfactory, but performed\nwell enough.\n\nThis is no longer needed.  There now exists a very wide variety of\nconfiguration management options, many of them providing continuous or on\ndemand configuration management after the install and possible deployment\nto another location.  The large variety of options now available implies\nthat there are good, bad, and ugly options.  There are very likely people\nthat consider salt either on the bad or ugly side and would\nlike another option, especially over what can be perceived as a hand-rolled and\nlittle tested crypto solution for communication, and for them, the configuration\nsystem is basically open.  The only places where salt is used in the\ninstall process is to add the apt repositories and install the minion and\ninitial config.  This is done in the preseed file and latecmd script.\nThe submission of a new machine will also generate minion keys that are\nstored in the database and preseeded to the minion during the latecmd.\n\n### Machine Administration\n\nThe primary goal of this project is to provide a nearly enterprise solution at a\nbudget price for smaller businesses and organizations that don't require the\nfull fledged expensive solution.  The growth of the internet, as well as the\nincreasing range and features of internet capable devices has created an\nenvironment where it is becoming a greater necessity to define stricter\nconfigurations and policies that keeps the business operating without\nfalling prey to the likelihood of increased problems and downtime as their\ndependencies on interaction over the internet and with each other increases or\notherwise changes,\n\nPaella includes a web application capable of administring the machines.\nCurrently this is just the barebones necessity required to perform simple\ninstallations with expert disk recipes.  Partition and RAID recipes\ncan be edited on the web application using the\n[ACE](http://ace.c9.io/#nav=about) text editor in the browser.  The recipe\neditor on the paella web application doesn't require the recipe to exist\non a single line, or\nto use backslash escaping to write the recipe.  The recipe can be written as a\nnormal multiline text file, that is later squeezed into the proper single line\nwhen the preseed template is filled and served.\n\nThe paella web server itself has been written with an eye towards the\nfuture.  The server is a [pyramid](http://www.pylonsproject.org/)\napplication using [cornice](https://github.com/mozilla-services/cornice) to\nprovide the\n[REST](http://en.wikipedia.org/wiki/Representational_state_transfer)\ninterface.  On the client side, in the browser,\neverything is a single page application.  The client application is written in\n[coffee-script](http://coffeescript.org) and\nuses [backbone.marionette](http://marionettejs.com/) as well as\nother good quality javascript libraries.\n\n### PXE/Netboot Environment\n\nPaella combines PXE booting, preseeded base debian \ninstalls, and [salt](https://saltstack.com) to install a fully configured \nsystem and maintain the configuration.  Paella can also automatically install\n[Microsoft Windows](https://microsoft.com) systems via PXE booting, however this\nis currently a feature that needs much work.  Proof of concept and some\nsample code is provided for the vagrant VM, but is disabled by default.\n\n**NOTE**: It should be noted here, or somewhere else, that a pxe netboot is not\nstrictly required to perform an automated installation, since all that is\nrequired is a syslinux config, preseed file, and possibly a different latecmd that\nwould keep the machine from continuously rebooting the debian installer.  PXE\ninstallation is the preferred method, due to the ease of administration compared\nto other methods.\n\nAs a consequence of having a netboot install environment, options that would\notherwise require the configuration of such an environment are already\navailable.  Diskless systems can be operated routinely.  There are also\nbackup/clone systems, recovery and repair systems, and also forensic or\nother specialized tools that would benefit from operating without writing to\nthe fixed media of the host is needed.\n\nA good example of this is that the windows installer works on a debian live\nsystem and uses wimlib to install a\n[WIM](http://en.wikipedia.org/wiki/Windows_Imaging_Format) file to an\nntfs partition,\nthen execute virtualbox to prepare the bootloader.  While this is happening\na user of the live system can browse the web or use office tools while they\nrecover from a malware attack or broken hard drive.\n\n###[System Dependencies](#pages/sysdeps)\n\nAlthough this is the last feature listed, it is by far the most important.\nThe selection of code and environment that paella depends upon has\nbeen chosen very carefully, but not by a team of people.  The\nselection of dependencies are crucial with respect to predictable\noperation and long term management.  A system such as\npaella has a heavy dependence on many system services, libraries, and\nframeworks in order to perform its function.  These dependencies can generally\nbe categorized into two distinct types.\n\nFirst, there are the system dependencies.  This may not be the best term, but\nthese dependencies are the selection of implmentations of the various services\nthat paella needs to install and configure systems.  These are things like DNS,\nDHCP, TFTP, HTTP, SMB, etc.  These are dependencies that used, rather than\nused or called directly by the paella python code.  I have chosed\nthe [ISC](http://isc.org) implementations\nof dns and dhcp, H. Peter Anvin's tftp server, the venerable Apache webserver,\nas well as Samba for implenting stable and reliable services.  While some of\nthese services are much more difficult to configure an operate compared to\nmany of the alternatives I have seen chosen for similar environments, the\nalternatives either do not provide the flexibility, or they don't appear to have\nas many eyes on the code, as the selections that I have made.\n\nSecond, there are the libraries that have been chosen to work with the\npaella application.  These can generally be divided into two classes, python\nand javascript.  This is where the selection of dependencies becomes much\nmore difficult.\n\n[Variations on a Theme](http://en.wikipedia.org/wiki/Variations_on_a_Theme)\n\n[Fugue](http://en.wikipedia.org/wiki/Fugue)\n\nI am hoping that the two links provided above come close to describing\nthe many alternatives that can be chosen to perform similar functions.  This\nis very difficult, and many times I have been left with no choice but to gamble.\n\nWhat is alive today can become dead and unmaintained quickly.  The effects\nmay not be felt until a long time after, but when this happens, something\nhas to be fixed.  What is stable, unchanged and predictable can also be\na sign of stagnation and a forecast for eventual removal from the\ndebian archive could be in the next release.  While it is impossible to\npredict this and keep it from happening, a careful selection of dependencies\ncan drastically reduce the frequency of those types of problems occurring.\n\nWhile some of the system services may be hard to work with and configure, the\nselection of software libraries that paella directly executes has been chosen\nto be as easy to work with as possible, without circumventing important things\nthat may potentially affect the predictability and reliabilty of the code.\n\nNevertheless, there should be at least one or two dependencies that will\nhave to be worked with in the next two years, if history and experience are\nany guide, which is why the selection process is so important, and it has\ntaken much of my time.\n\n\nWhile the possibilities seem numerous, the cold hard fact is that this is a\nproject created by a single developer to perform installation and configuration\nmanagement operations on a smaller range of operating systems and\nhardware configurations.  However, I have taken the time to keep the\nframework open and flexible.  The configuration management system is\nactually an open and fair game.  There should not be much difficulty in\nusing another system such as ansible or puppet if desired.  The example\nsalt configuration that is provided isn't required for operation, and is also\nnot highly opinionated.\n\nThe machine management data is split between a postgresql database\nand the configuration management system, which is currently salt.  The\npostgresql database houses the minion_id/hostname and system-uuid\nof the machine, as well as the disk configuration held in the form of\ndebian-installer expert recipes.  The decision to have this split, instead\nof a centralized data store stems from the desire to keep the configuration\nmanagement system as open as possible and determine the best way\nto link the information in the database to the preferred configuration\nsystem.  I feel that this opportunity for flexibility overrides the desire for\na completely central database at this point in the development of the\nproject.\n\n", "id": "features"}