{"content": "# [Features](#)\n\n\nPaella has some features that may make it desirable over other\nautomated installation options.\n\n## Self Hosting\n\nThe development environment, using [vagrant](FIXME), creates a\n[virtual box](FIXME) server with two interfaces that is ready to\nperform automated installs.  All that is needed is to clone the\nproject from [github](FIXME) and type `vagrant up` (and sadly,\nfollowed by one `vagrant provision`, due to a small bug in the ordering\nof states) and you are ready to start submitting machines and instaling.\n\nThe vagrant virtual machine can also install to bare metal if you bridge the\nsecondary network interface on the VM to a real network interace on the host.\n\n## Modern Design\n\nAfter spending the better part of thirteen years automatically installing and\nsemi-automatically maintaining configurations on quite a few debian systems,\nranging from servers to desktops and simple devices running debian, I have\nlearned plenty about installing debian systems, as well as a few others.\n\n### Debian Installer\n\nI have learned to make use of the debian installer to perform the initial\ninstall phase, rather than continue the tradition of debootstrapping from\na live system into a target directory on the system drive.  There are a\nsurprising about of small technical details that the debian installer handles,\nand these details happen to change from release to release in ways that\nforces more maintainence than is desired on the debootstrap install\nmethod.\n\nAt it's heart, if you pay close attention, the debian installer is an API for\ninstalling debian systems, controlled entirely by the preseed file and the\nkernel command line.  The debian developers provide all of the implementation\ndetails to install the system you declare in the preseed and command line.\nUsing the debian installer makes long term maintainence easier, at the\nexpense of having to keep track of the state of the machine when it\nreboots (thankfully, this is only once).  FIXME - there is another page\nthat gives details on how the install procedure operates.\n\n### Configuration Management\n\nConfiguration management extends beyond a preconfigured installation.  When\nthe desire to create an automated installer that created fully configured\nsystems originated, configuration management as it is seen today was\nnowhere nearly as mature.  There existed [cfengine](FIXME) and an assortment\nof less complete solutions to the serious problems that lack of good\nconfiguration managment eventually incurs.  Cfengine was written perl, which\nI really don't like using.  I was forced, as many other administrators at the time,\nto implement a hand-rolled solution, which, as expected, was less than completely\nsatisfactory, but performed well enough.\n\nThis is no longer needed.  There now exists a plethora of configuration management\noptions, many of them providing continuous or on demand configuration management\nafter the install and possible deployment to another location.  The large variety of\noptions now available implies that there are good, bad, and ugly options.  There\nare very likely people that consider salt either on the bad or ugly side and would\nlike another option, especially over what can be perceived as a hand-rolled and\nlittle tested crypto solution for communication, and for them, the configuration\nsystem is basically open.  The only places where salt is used in the install process\nis to add the apt repositories and install the minion and initial config.  This is\ndone in the preseed file and latecmd script.  The submission of a new machine\nwill also generate minion keys that are stored in the database and preseeded\nto the minion during the latecmd.\n\n### Machine Administration\n\nThe primary goal of this project is to provide a nearly enterprise solution at a\nbudget price for smaller businesses and organizations that don't require the\nfull fledged expensive solution.  The growth of the internet, as well as the\nincreasing range and features of internet capable devices has created an\nenvironment where it is becoming a greater necessity to define stricter\nconfigurations and policies that keeps the business operating without\nfalling prey to the likelihood of increased problems and downtime as their\ndependencies on interaction over the internet and with each other increases or\notherwise changes,\n\nPaella includes a web application capable of administring the machines.  Currently\nthis is just the barebones necessity required to perform simple installations with\nexpert disk recipes.  Partition and RAID recipes can be edited on the web\napplication using the [ACE](FIXME) text editor in the browser.  The recipe editor\non the paella web application doesn't require the recipe to exist on a single line, or\nto use backslash escaping to write the recipe.  The recipe can be written as a\nnormal multiline text file, that is later squeezed into the proper single line\nwhen the preseed template is filled and served.\n\nThe paella web server itself has been written with an eye towards the\nfuture.  The server is a [pyramid](FIXME) application using [cornice](FIXME) to\nprovide the [REST](FIXME) interface.  On the client side, in the browser,\neverything is a single page application.  The client application is written in\n[coffee-script](FIXME) and uses [backbone.marionette](FIXME) as well as\nother good quality javascript libraries.\n\n### PXE/Netboot Environment\n\nPaella combines PXE booting, preseeded base debian \ninstalls, and [salt](https://saltstack.com) to install a fully configured \nsystem and maintain the configuration.  Paella can also automatically install\n[Microsoft Windows](https://microsoft.com) systems via PXE booting, however this\nis currently a feature that needs much work.  Proof of concept and some\nsample code is provided for the vagrant VM, but is disabled by default.\n\n**NOTE**: It should be noted here, or somewhere else, that a pxe netboot is not\nstrictly required to perform an automated installation, since all that is\nrequired is a syslinux config, preseed file, and possibly a different latecmd that\nwould keep the machine from continuously rebooting the debian installer.  PXE\ninstallation is the preferred method, due to the ease of administration compared\nto other methods.\n\nAs a consequence of having a netboot install environment, options that would\notherwise require the configuration of such an environment are already\navailable.  Diskless systems can be operated routinely.  There are also\nbackup/clone systems, recovery and repair systems, and also forensic or\nother specialized tools that would benefit from operating without writing to\nthe fixed media of the host is needed.\n\nA good example of this is that the windows installer works on a debian live\nsystem and uses wimlib to install a [WIM](FIXME) file to an ntfs partition,\nthen execute virtualbox to prepare the bootloader.  While this is happening\na user of the live system can browse the web or use office tools while they\nrecover from a malware attack or broken hard drive.\n\n### System Dependencies\n\nAlthough this is the last feature listed, it is by far the most important.  The selection\nof code and environment that paella depends upon has been chosen very\ncarefully, but not by a team of people.  The selection of dependencies are crucial with\nrespect to predictable operation and long term management.  A system such as\npaella has a heavy dependence on many system services, libraries, and\nframeworks in order to perform its function.  These dependencies can generally\nbe categorized into two distinct types.\n\nFirst, there are the system dependencies.  This may not be the best term, but\nthese dependencies are the selection of implmentations of the various services\nthat paella needs to install and configure systems.  These are things like DNS,\nDHCP, TFTP, HTTP, SMB, etc.  These are dependencies that used, rather than\nused or called directly by the paella python code.  I have chosed\nthe [ISC](FIXME) implementations\nof dns and dhcp, H. Peter Alvin's tftp server, the venerable Apache webserver,\nas well as Samba for implenting stable and reliable services.  While some of\nthese services are much more difficult to configure an operate compared to\nmany of the alternatives I have seen chosen for similar environments, the\nalternatives either do not provide the flexibility, or they don't appear to have\nas many eyes on the code, as the selections that I have made.\n\nSecond, there are the libraries that have been chosen to work with the\npaella application.  These can generally be divided into two classes, python\nand javascript.  This is where the selection of dependencies becomes much\nmore difficult.\n\n[Variations on a Theme](http://en.wikipedia.org/wiki/Variations_on_a_Theme)\n\n[Fugue](http://en.wikipedia.org/wiki/Fugue)\n\nI am hoping that the two links provided above come close to describing\nthe many alternatives that can be chosen to perform similar functions.  This\nis very difficult, and many times I have been left with no choice but to gamble.\n\nWhat is alive today can become dead and unmaintained quickly.  The effects\nmay not be felt until a long time after, but when this happens, something\nhas to be fixed.  What is stable, unchanged and predictable can also be\na sign of stagnation and a forecast for eventual removal from the\ndebian archive could be in the next release.  While it is impossible to\npredict this and keep it from happening, a careful selection of dependencies\ncan drastically reduce the frequency of those types of problems occurring.\n\nWhile some of the system services may be hard to work with and configure, the\nselection of software libraries that paella directly executes has been chosen\nto be as easy to work with as possible, without circumventing important things\nthat may potentially affect the predictability and reliabilty of the code.\n\nNevertheless, there should be at least one or two dependencies that will\nhave to be worked with in the next two years, if history and experience are\nany guide, which is why the selection process is so important, and it has\ntaken much of my time.\n\n", "id": "features"}